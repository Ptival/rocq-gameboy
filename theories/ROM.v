From Bits Require Import bits.
From Coq Require Import FSets.FMapAVL.
From Coq Require Import Hexadecimal.
From Coq Require Import List.
From Coq Require Import ssreflect.
From Coq Require Import Structures.OrderedTypeEx.
From Coq Require Import Classes.RelationClasses.
From mathcomp Require Import all_ssreflect.

Import ListNotations.

Open Scope hex_uint_scope.

Definition BYTE := BITS 8.
Definition ADDR := BITS 16.

Fixpoint indexed_from {A} (n : nat) (l : list A) : list (ADDR * A) :=
  match l with
  | [] => []
  | h::t => (fromNat n, h) :: indexed_from (S n) t
  end.

Definition indexed {A} (l : list A) := indexed_from 0 l.

Definition test : BYTE := # 0xfa.

Notation "'ROM' a ',' .. ',' b" := (indexed (cons (@fromNat 8 a) .. (cons (@fromNat 8 b) nil) ..)) (at level 200).

Definition bootROMBytes := ROM
0xfe , 0x31 , 0xaf , 0xff , 0xff , 0x21 , 0x32 , 0x9f , 0x7c , 0xcb , 0xfb , 0x20 , 0x26 , 0x21 , 0x0e, 0xff,
0x3e , 0x11 , 0x32 , 0x80 , 0x0c , 0xe2 , 0xf3 , 0x3e , 0x32 , 0xe2 , 0x77 , 0x3e , 0x3e , 0x77 , 0xe0, 0xfc,
0x21 , 0x47 , 0x01 , 0x04 , 0x11 , 0xe5 , 0x00 , 0xcb , 0x13 , 0x1a , 0x20 , 0xbe , 0x23 , 0x6b , 0xfe, 0x7d,
0x20 , 0x34 , 0x06 , 0xf5 , 0x78 , 0x19 , 0x23 , 0x86 , 0x20 , 0x05 , 0x86 , 0xfb , 0x5a , 0x20 , 0x21, 0xd1,
0x80 , 0x10 , 0xcd , 0x1a , 0x00 , 0xa9 , 0xaa , 0xcd , 0x13 , 0x00 , 0xfe , 0x7b , 0x20 , 0x34 , 0x3e, 0xf3,
0x21 , 0x18 , 0x99 , 0x2f , 0x0c , 0x0e , 0x3d , 0x32 , 0x09 , 0x28 , 0x20 , 0x0d , 0x11 , 0xf9 , 0xff, 0xec,
0x18 , 0x19 , 0x67 , 0xf1 , 0x64 , 0x3e , 0xe0 , 0x57 , 0x3e , 0x42 , 0xe0 , 0x91 , 0x04 , 0x40 , 0x02, 0x1e,
0xbc , 0xcd , 0x0e , 0x00 , 0x24 , 0x13 , 0x1e , 0x7c , 0xfe , 0x83 , 0x28 , 0x62 , 0x1e , 0x06 , 0xfe, 0xc1,
0x20 , 0x64 , 0x7b , 0x06 , 0x0c , 0xe2 , 0x87 , 0x3e , 0xf0 , 0xe2 , 0x90 , 0x42 , 0x42 , 0xe0 , 0x20, 0x15,
0x05 , 0xdd , 0x69 , 0x20 , 0x20 , 0x16 , 0xd6 , 0x18 , 0x91 , 0x3e , 0x40 , 0xe0 , 0x14 , 0x1e , 0xbc, 0xcd,
0xf0 , 0x00 , 0xee , 0x47 , 0xe0 , 0xff , 0x18 , 0x47 , 0x4f , 0xf3 , 0x04 , 0x06 , 0xcb , 0xc5 , 0x17, 0x11,
0xcb , 0xc1 , 0x17 , 0x11 , 0x20 , 0x05 , 0x22 , 0xf5 , 0x22 , 0x23 , 0xc9 , 0x23 , 0x0c , 0x0e , 0x44, 0xf0,
0x90 , 0xfe , 0xfa , 0x20 , 0x20 , 0x0d , 0x1d , 0xf7 , 0xf2 , 0x20 , 0xce , 0xc9 , 0x66 , 0xed , 0xcc, 0x66,
0x00 , 0x0d , 0x03 , 0x0b , 0x00 , 0x73 , 0x00 , 0x83 , 0x00 , 0x0c , 0x00 , 0x0d , 0x11 , 0x08 , 0x88, 0x1f,
0x00 , 0x89 , 0xdc , 0x0e , 0x6e , 0xcc , 0xdd , 0xe6 , 0xd9 , 0xdd , 0xbb , 0x99 , 0x67 , 0xbb , 0x6e, 0x63,
0xec , 0x0e , 0xdd , 0xcc , 0x99 , 0xdc , 0xbb , 0x9f , 0x33 , 0xb9 , 0xff , 0x3e , 0x3c , 0xff , 0x50, 0xe0.

Module BITS16_as_OT <: UsualOrderedType.
  Definition t := BITS 16.
  Definition eq := @eq t.
  Definition eq_refl := @Logic.eq_refl t.
  Definition eq_sym := @Logic.eq_sym t.
  Definition eq_trans := @Logic.eq_trans t.

  Definition lt (a b : t) := is_true (ltB a b).
  Definition lt_trans := @ltB_trans 16.
  Lemma lt_not_eq (x y : t) : lt x y -> ~ eq x y.
  Proof.
    rewrite /lt ltB_nat /eq.
    move => LT EQ.
    move : LT.
    by rewrite EQ {EQ} ltnn.
  Qed.

  Definition compare (x y : t) : OrderedType.Compare lt eq x y.
    case E1 : (ltB x y).
    * by apply : OrderedType.LT.
    * case E2 : (x == y).
      - apply : OrderedType.EQ.
        rewrite /eq.
        by apply : eqP.
      - apply OrderedType.GT.
        rewrite /lt ltB_nat.
        move : E1. rewrite ltB_nat => E1.
        Search leq.
  Defined.

  Definition eq_dec (x y : t) := decP (x =P y).

End BITS16_as_OT.

Module AddrMap := FMapAVL.Make BITS16_as_OT.
Definition Memory := AddrMap.t BYTE.

Definition memoryFromBytes (l : list (ADDR * BYTE)) : Memory :=
  List.fold_right (fun '(k, v) m => AddrMap.add k v m) (@AddrMap.empty _) l.

Definition bootROMMap := memoryFromBytes bootROMBytes.

Definition x := AddrMap.find (fromNat 1) bootROMMap.

Eval compute in x.
